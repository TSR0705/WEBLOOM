# Observability, Monitoring & Performance Visibility

This document defines how Webloom exposes metrics, logs, events, and traces to allow users, developers, and administrators to understand system behavior at every stage of the scraping pipeline.

The goal is simple:

No run should ever feel like a "black box."
Anyone seeing the dashboard must immediately understand:
what is running, what happened, what changed, and why.

## 1. Core Observability Principles

- Every pipeline hop generates a traceable event
- Every run is persistently logged
- UI exposes execution progression clearly
- Errors are surfaced, NOT hidden
- Storage footprint stays small and TTL-managed
- Monitoring does NOT require expensive logging infrastructure.
- Everything fits into free-tier MongoDB.

## 2. Observability Pipeline Diagram

Agents produce logs/events â†’
Events aggregated â†’
Stored in MongoDB (short TTL) â†’
Streamed to UI via SSE â†’
Displayed in dashboard â†’
Indexed for analytics â†’
Auto-expired when old

## 3. Observability Data Classes

Webloom tracks four levels of observability:

| Level | Purpose |
|-------|---------|
| Run-Level | Execution milestones |
| Page-Level | Where changes occurred |
| Price Events | Time-series tracking |
| System-Level | Worker and queue state |

These are mapped into collections:

- job_runs
- change_logs
- price_history
- events
- worker_heartbeats

## 4. Metrics Tracked

### 4.1 Job Run Metrics

Stored in job_runs.metrics

| Metric | Meaning |
|--------|---------|
| avgFetchMs | average HTTP fetch time |
| maxFetchMs | longest HTTP fetch |
| queueDepthMax | largest queue backlog |
| agentRestarts | recovery count |

**Usage in UI:**

- Shows slow websites
- Helps evaluate performance
- Acts as anti-ban timeout metric

### 4.2 Workflow-Level Metrics

Generated by Scheduler:

| Metric | Description |
|--------|-------------|
| runsPerDay | usage tracking |
| pagesPerRun | load impact |
| scheduledDelays | scheduler lag |

These produce clear trend graphs.

### 4.3 Storage Metrics

Tracked in lightweight service:

| Metric | Source |
|--------|--------|
| totalSnapshots | count from TTL collection |
| totalPages | pages collection |
| totalJobs | jobs collection |

Thresholds used:

80% DB storage â†’ pause future pipelines

### 4.4 Real-Time System Pulse (Heartbeat)

Every agent writes:

worker_heartbeats

Document:

```json
{
  "agent": "scraper-agent",
  "instanceId": "scr1",
  "processedLastMin": 53,
  "memoryMb": 42,
  "ts": "2025-12-05T12:51:23Z"
}
```

UI shows:

Scraper agent: 53 pages/min. Good.

## 5. Real-Time Observability

Webloom achieves "live" experience using:

Server-Sent Events (SSE)

At gateway:

```
GET /api/events/stream
```

Frontend subscribes:

```javascript
const stream = new EventSource("/api/events/stream");
stream.onmessage = msg => addEvent(msg.data);
```

**Event Classes Emitted Live:**

| Event Type | Trigger Agent |
|------------|---------------|
| JOB_STARTED | scheduler |
| FETCH_OK | scraper |
| FETCH_FAILED | scraper |
| PAGE_PARSED | parser |
| CLASSIFIED | classifier |
| PRICE_CHANGE | price tracker |
| CHANGES_FOUND | change detector |
| STORED | storage agent |
| NOTIFIED | notifier |

Example event:

```json
{
  "type": "CHANGES_FOUND",
  "payload": {
    "jobId": "abc123",
    "url": "https://xyz/product/5",
    "diffSummary": "-â‚¹600 drop"
  },
  "ts": 1733412239000
}
```

Shown instantly in UI.

## 6. Observability UI Panels

The dashboard exposes:

### ðŸŸ¦ Panel 1: Live Console

Streamed log feed:

```
[10:18:02] Scraped page 1/14
[10:18:03] Price decreased by â‚¹400
[10:18:05] Snapshot stored
```

Recruiters love seeing this in interviews.

### ðŸŸ§ Panel 2: Job Analytics

Graphs:

- Pages per run
- Price fluctuations
- Changes over time
- Errors per run

### ðŸŸ© Panel 3: System Health

Shows:

- queue backlog
- agent heartbeat
- last activity timestamp

Alert example:

Classifier agent inactive for 12 minutes

### ðŸŸ¥ Panel 4: Recent Failures

With cause analysis:

```
URL: https://site.com/page/5
Failure: FETCH_TIMEOUT
Retry count: 2
Outcome: stored failed entry
```

Click â†’ view trace
Click â†’ view retry details

## 7. Debugging Experience

Debug workflow is:

**Step 1**

Open run detail page:

```
GET /jobs/[jobId]/runs/[runId]
```

**Step 2**

Inspect per-event trace

**Step 3**

Navigate to failed page snapshot

**Step 4**

Click CHANGE DIFF
â†’ shows new vs old state

**Step 5**

Check logs for retry reason

**Step 6**

Fix or re-run job

This is professional-grade troubleshooting.

## 8. Backend Logging Implementation Strategy

Each agent uses:

structured JSON logging

Log format:

```json
{
  "level": "info",
  "agent": "parser-agent",
  "msg": "Parsed HTML",
  "urlHash": "843af3c22a",
  "jobId": "abc123",
  "runId": "run_45",
  "ts": 1733412437000
}
```

Stored temporarily ONLY IF meaningful.

Logs older than 72h â†’ expire â†’ no bloating.

## 9. How Logs Stay Free Tier-Safe

Policy:

Only meaningful logs persist.
Transient logs streamed but not persisted.

**Persisted Logs:**

- failures
- price-change events
- change-detected events
- job transitions

**Discarded Logs:**

- "fetch succeeded"
- "selectors applied"

**Reason:**
Enough visibility already exists through metrics.

## 10. Business-Level Observability Advantages

For recruiters/interview panels:

- Shows distributed pipeline orchestration
- Shows ability to measure performance
- Shows user-oriented UX for internal processes
- Demonstrates real production mental model

This elevates Webloom from:
"just a scraper"
to
"intelligent observable data platform."

## 11. Real SaaS Justification

All mature SaaS products expose:

- system workload
- failure reason
- statistics
- insights

With Webloom, you replicate:

- DataDog-like event streams
- Segment-like histories
- Amplitude-like trend visualization

WITHOUT COST.

## 12. Quick Observability Checklist

When system works properly:

**User sees**

âœ” What is happening
âœ” What changed
âœ” Why the change occurred
âœ” What will happen next

**Developer sees**

âœ” Why something failed
âœ” Where pipeline broke
âœ” Which message is blocked
âœ” How many retry attempts
âœ” What data caused issue

## 13. Summary

Observability in Webloom is engineered to:

- provide deep insights
- keep system responsive
- run inside free tier
- avoid black-box behavior
- accelerate debugging

The combination of:

âœ” SSE
âœ” structured metrics
âœ” short-lived logs
âœ” TTL
âœ” rich dashboard views

makes Webloom operationally transparent and performant.

This document is part of Webloom's internal reliability architecture.

END OF FILE